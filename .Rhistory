TREAT %>% filter(symbol == "Gabbr1") #
TREAT %>% filter(symbol == "Gabbr2") # no
# gaba production
TREAT %>% filter(symbol == "Gadb") #
# gaba production
TREAT %>% filter(symbol == "Gadc") #
# gaba production
TREAT %>% filter(symbol == "Gadr") #
# gaba other
TREAT %>% filter(symbol == "Gabarap") #
TREAT %>% filter(symbol == "Gad1") # no
TREAT %>% filter(symbol == "Gad2") # no
TREAT %>% filter(symbol == "Gpr37") # no
# oxytocin?
TREAT %>% filter(symbol == "Oxt") # no
# oxytocin?
TREAT %>% filter(symbol == "Oxtr") # no
TREAT %>% filter(symbol == "Cd38") # no
# estrogen R
TREAT %>% filter(symbol == "Esr1") # no
TREAT %>% filter(symbol == "Esr2") # no
# estrogen R
TREAT %>% filter(symbol == "Nr3b1") # no
# estrogen R
TREAT %>% filter(symbol == "Esrra") # no
TREAT %>% filter(symbol == "Esrrb") # no
TREAT %>% filter(symbol == "Esr2") # no
TREAT %>% filter(symbol == "Esrrb") # no
TREAT <- readRDS("results/TREATMENT_limma_results.RDS")
males <- readRDS("results/Elevel_M_limma_results.RDS")
low <- readRDS("results/Elevel_low_limma_results.RDS")
high <- readRDS("results/Elevel_high_limma_results.RDS")
oil <- readRDS("results/Oil_limma_results.RDS")
opfr <- readRDS("results/OPFR_limma_results.RDS")
y1a$M_v_low %>% filter(symbol == "Oxt") #
oil$M_v_low %>% filter(symbol == "Oxt") #
oil$M_v_low %>% filter(symbol == "Oxtr") #
oil$M_v_high %>% filter(symbol == "Oxt") #
oil$M_v_high %>% filter(symbol == "Oxtr") #
oil$low_v_high %>% filter(symbol == "Oxtr") #
opfr$M_v_low %>% filter(symbol == "Oxtr") #no
opfr$M_v_high %>% filter(symbol == "Oxtr") #no
opfr$low_v_high %>% filter(symbol == "Oxtr") #no
oil$M_v_low %>% filter(symbol == "Cd38") #no
oil$M_v_high %>% filter(symbol == "Cd38") #no
oil$low_v_high %>% filter(symbol == "Cd38") #no
opfr$M_v_low %>% filter(symbol == "Cd38") #no
opfr$M_v_high %>% filter(symbol == "Cd38") #no
opfr$low_v_high %>% filter(symbol == "Cd38") #no
oil$M_v_low %>% filter(symbol == "Esrra") #no
oil$M_v_high %>% filter(symbol == "Esrra") #no
oil$low_v_high %>% filter(symbol == "Esrra") #no
opfr$M_v_low %>% filter(symbol == "Esrra") #no
opfr$M_v_high %>% filter(symbol == "Esrra") #no
opfr$low_v_high %>% filter(symbol == "Esrra") #no
oil$M_v_low %>% filter(symbol == "Gabra2") #no
oil$M_v_high %>% filter(symbol == "Gabra2") #no
oil$low_v_high %>% filter(symbol == "Gabra2") #no
opfr$M_v_low %>% filter(symbol == "Gabra2") #no
opfr$M_v_high %>% filter(symbol == "Gabra2") #no
opfr$low_v_high %>% filter(symbol == "Gabra2") #no
TREAT %>% filter(symbol == "Slc32a1") # no
oil$M_v_low %>% filter(symbol == "Slc32a1") #no
oil$M_v_high %>% filter(symbol == "Slc32a1") #no
oil$low_v_high %>% filter(symbol == "Slc32a1") #no
opfr$M_v_low %>% filter(symbol == "Slc32a1") #no
opfr$M_v_high %>% filter(symbol == "Slc32a1") #no
opfr$low_v_high %>% filter(symbol == "Slc32a1") #no
TREAT %>% filter(symbol == "Gad67") # no
TREAT %>% filter(symbol == "Gad1") # no
#other
TREAT %>% filter(symbol == "Hsd11b2") # no
#other
TREAT %>% filter(symbol == "Sdr9c3") # no
#other
TREAT %>% filter(symbol == "Ame") # no
#other
TREAT %>% filter(symbol == "Ame1") # no
#other
TREAT %>% filter(symbol == "Hsd2") # no
#other
TREAT %>% filter(symbol == "Hsd11k") # no
#other
TREAT %>% filter(symbol == "Hsd11b") # no
#other
TREAT %>% filter(symbol == "Hsd11b2") # no
TREAT %>% filter(symbol == "Sod2") # no
library(limma)
library(edgeR)
library(Mus.musculus)
organism = 'org.Mm.eg.db'
library(organism, character.only = TRUE)
library(biomaRt)
library(AnnotationDbi)
library(pheatmap)
library(annotables)
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(tidyverse)
grcm38 # mouse genes
source("functions/gettop10GO.R")
my_logFC_threshold = 0.2
TREAT <- readRDS("results/TREATMENT_limma_results.RDS")
males <- readRDS("results/Elevel_M_limma_results.RDS")
low <- readRDS("results/Elevel_low_limma_results.RDS")
high <- readRDS("results/Elevel_high_limma_results.RDS")
oil <- readRDS("results/Oil_limma_results.RDS")
opfr <- readRDS("results/OPFR_limma_results.RDS")
oil_mvlow <- oil$M_v_low
View(oil_mvlow)
oil_mvhigh <- oil$M_v_high
oil_lvh <- oil$low_v_high
opfr_mvlow <- opfr$M_v_low
opfr_mvhigh <- opfr$M_v_high
oil_mvlow <- oil$M_v_low
oil_mvhigh <- oil$M_v_high
oil_lvh <- oil$low_v_high
opfr_mvlow <- opfr$M_v_low
opfr_mvhigh <- opfr$M_v_high
opfr_lvh <- opfr$low_v_high
gettop10GO(oil_mvlow, my_showCategory) %>%
mutate(comparison = "Oil - OPFR") -> top10_GOterms_oil_mvlow
View(top10_GOterms_oil_mvlow)
gettop10GO(oil_mvlow, my_showCategory) %>%
mutate(comparison = "M - low") -> top10_GOterms_oil_mvlow
gettop10GO(oil_mvhigh, my_showCategory) %>%
mutate(comparison = "M - high") -> top10_GOterms_oil_mvhigh
View(top10_GOterms_oil_mvlow)
View(top10_GOterms_oil_mvhigh)
gettop10GO(oil_lvh, my_showCategory) %>%
mutate(comparison = "low - high") -> top10_GOterms_oil_lowvhigh
View(top10_GOterms_oil_lowvhigh)
gettop10GO(opfr_mvlow, my_showCategory) %>%
mutate(comparison = "M - low") -> top10_GOterms_opfr_mvlow
gettop10GO(opfr_mvhigh, my_showCategory) %>%
mutate(comparison = "M - high") -> top10_GOterms_opfr_mvhigh
gettop10GO(opfr_lvh, my_showCategory) %>%
mutate(comparison = "low - high") -> top10_GOterms_opfr_lowvhigh
View(top10_GOterms_opfr_mvlow)
View(top10_GOterms_oil_mvlow)
View(top10_GOterms_opfr_mvhigh)
View(top10_GOterms_oil_mvhigh)
# TREATMENT only WGCNA
# actually, with the way WGCNA works -- this can be for treatment then 6-pairwise right after, right??
# BiocManager::install("")
library(WGCNA)
library(DESeq2)
library(GEOquery)
library(CorLevelPlot)
library(gridExtra)
library(clusterProfiler)
library(enrichplot)
library(biomaRt)
library(AnnotationDbi)
library(annotables)
grcm38 <- grcm38
library(tidyverse)
source("functions/gettop10GO.R")
allowWGCNAThreads()          # allow multi-threading (optional)
data <- read.csv("rawdata/KT_Counts.csv")
phenoData <- read.csv("rawdata/kim rnaseq phenodata.csv")
data[1:10, 1:10]
head(phenoData)
# prepare data
data <- data %>%
gather(key = "samples", value = "counts", -X) %>%
rename(gene = X) %>%
inner_join(., phenoData, by = c("samples" = "id")) %>%
select(1, 3, 2) %>%
spread(key = "samples", value = "counts") %>%
column_to_rownames(var = "gene")
# 2. QC - outlier detection ------------------------------------------------
# detect outlier genes
gsg <- goodSamplesGenes(t(data))
summary(gsg)
gsg$allOK
table(gsg$goodGenes)
table(gsg$goodSamples)
# remove genes that are detected as outliers
data <- data[gsg$goodGenes == TRUE,]
# detect outlier samples - hierarchical clustering - method 1
htree <- hclust(dist(t(data)), method = "average")
plot(htree)
# KT021 definitely outlier.  and maybe KT004
# pca - method 2 for finding outliers
pca <- prcomp(t(data))
pca.dat <- pca$x
pca.var <- pca$sdev^2
pca.var.percent <- round(pca.var/sum(pca.var)*100, digits = 2)
pca.dat <- as.data.frame(pca.dat)
ggplot(pca.dat, aes(PC1, PC2)) +
geom_point() +
geom_text(label = rownames(pca.dat)) +
labs(x = paste0('PC1: ', pca.var.percent[1], ' %'),
y = paste0('PC2: ', pca.var.percent[2], ' %'))
# less clear here -- going to go back to my voom transformed data and look at those PCAs -- if KT021 is the oilier over there too, will remove from this analysis and prior analyses too (damnit)
# ok remove KT021 lol
# exclude outlier samples
samples.to.be.excluded <- c('KT021')
data.subset <- data[,!(colnames(data) %in% samples.to.be.excluded)]
### ***  note in results that we exclude KT021 because of higher variance compared to all other samples
# 3. Normalization ----------------------------------------------------------------------
# create a deseq2 dataset
phenoData <- phenoData %>%
column_to_rownames(var = "id")
# exclude outlier samples
colData <- phenoData %>%
filter(!row.names(.) %in% samples.to.be.excluded)
# # fixing column names in colData ---- unneccessary here, all clean already
# names(colData)
#
# # selecting relevant info
# colData <- colData %>%
#   select(3, 10, 11, 13, 14, 15, 20, 22)
# making the rownames and column names identical
all(rownames(colData) %in% colnames(data.subset))
all(rownames(colData) == colnames(data.subset))
#good
# create dds
dds <- DESeqDataSetFromMatrix(countData = data.subset,
colData = colData,
design = ~ 1) # not specifying model "because we need this DSeq data set to perform variance stabilizing transformation"
## remove all genes with counts < 15 in more than 75% of samples (29*0.75=22)
## suggested by WGCNA on RNAseq FAQ
dds75 <- dds[rowSums(counts(dds) >= 15) >= 22,]
nrow(dds75) # 14068 genes
# perform variance stabilization
dds_norm <- vst(dds75)
# get normalized counts
norm.counts <- assay(dds_norm) %>%
t()
# 4. Network Construction  ---------------------------------------------------
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2))
power
# Call the network topology analysis function
sft <- pickSoftThreshold(norm.counts,
powerVector = power,
networkType = "signed",
verbose = 5)
sft.data <- sft$fitIndices
# visualization to pick power
a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
geom_hline(yintercept = 0.8, color = 'red') +
labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
theme_classic()
a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
geom_point() +
geom_text(nudge_y = 0.1) +
labs(x = 'Power', y = 'Mean Connectivity') +
theme_classic()
grid.arrange(a1, a2, nrow = 2)
# power 9 or 10 - maybe even 8-12
# start with 9
# try cranking it up to 12 -- this is likely going to overfit, have low number of MEs. let's see.
# nope lol
# try 8 - definite lowest we  can go. - still 1 sig ME, but only 16 MEs total. underfit?
# final test, power 10 -- 12 MEs, 0 sig -- overfit
### power 9 it is. Trust your gut.
# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
soft_power <- 9
temp_cor <- cor
cor <- WGCNA::cor
# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
maxBlockSize = 15000, # 14000 is suitable for 16gigs of RAM in PC
TOMType = "signed",
power = soft_power,
mergeCutHeight = 0.25, #threshold of merging simmilar modules
numericLabels = FALSE, #to set model eigengene labels as colors
randomSeed = 1234,
verbose = 3)
cor <- temp_cor
# 5. Module Eigengenes ---------------------------------------------------------
module_eigengenes <- bwnet$MEs
# Print out a preview
head(module_eigengenes)
# get number of genes for each module
table(bwnet$colors)
# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
c("unmerged", "merged"),
dendroLabels = FALSE,
addGuide = TRUE,
hang= 0.03,
guideHang = 0.05)
# grey module = all genes that doesn't fall into other modules were assigned to the grey module
# 6A. Relate modules to traits --------------------------------------------------
# module trait associations
# create traits file - binarize categorical variables
traits <- colData %>%
mutate(treatment_bin = ifelse(grepl('OPFR', treatment), 1, 0)) %>%
select(6)
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
# View(module.trait.corr.pvals)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
### NEED TO adjust this step depending on dimensions of heatmap.data
names(heatmap.data)
# 9 power, 19 MEs --
# 12 power, 13 MEs
# 8 power, 16 MEs
# 10 power, 12 MEs (???)
# 9 power but run in 1 block -> 14 MEs...
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
names(heatmap.data2)
heatmap.data_TREAT_only <- heatmap.data
## IN THE FOLLOWING: POSITIVE VALUES MEAN ME EXPRESSION IN HIGHER IN TRAIT CODED WITH 1 COMPARED TO TRAIT CODED WITH 0 - specifically positive = higher in OPFR
### SAVE 550x800
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[15:15], #trait data
y = names(heatmap.data2)[1:14], #ME data
col = c("skyblue", "lightblue", "white", "pink", "hotpink"),
main = "A. Treatment Only
WGCNA Module Eigengenes")
## when power = 9, only 1 module is affected.
## power = 12, 0 sig MEs
## power = 8, 1 sig ME,
## power = 10, 0 sig. - too overfit
#### power 9 it is.
## a little is different when run power 9 in one block.  still only 1 ME different.
module.gene.mapping <- as.data.frame(bwnet$colors)
## FROM HERE, CAN PERFORM FURTHER ANALYSIS ON GENES IN IMPORTANT MODULES - the following lists the genes in relevant modules that are selected from above analysis to be modules that are differentially expressed between groups
## THIS ME has HIGHER expression in Stress
module.gene.mapping %>%
filter(`bwnet$colors` == 'salmon') %>%
rownames()
# 6B. Intramodular analysis: Identifying driver genes ---------------
#"highly connected intramodular hub genes"
# Calculate the module membership and the associated p-values
# The module membership/intramodular connectivity is calculated as the correlation of the eigengene and the gene expression profile.
# This quantifies the similarity of all genes on the array to every module.
module.membership.measure <- cor(module_eigengenes, norm.counts, use = 'p')
module.membership.measure.pvals <- corPvalueStudent(module.membership.measure, nSamples)
module.membership.measure[1:10,1:10]
module.membership.measure.pvals[1:10,1:10] # just a check that this ran right
# Calculate the gene significance and associated p-values
#correlate expression data with trait of interest - FOR ME, JUST stress_bin
gene.signf.corr <- cor(norm.counts, traits$treatment_bin, use = 'p')
gene.signf.corr.pvals <- corPvalueStudent(gene.signf.corr, nSamples)
gene.signf.corr.pvals %>%
as.data.frame() %>%
arrange(V1) %>%
head(25)
#top 25 genes sig associated with OPFR experience
### NEED TO DO SOMETHING SIMILAR TO THIS *JUST* WITHIN SIG MODULES - GET "HIGHEST MM GENES"   ### basically take module.membership.measure.pvals, flip orientation, filter only relevant module, then arrange(V1)
#### FOLLOWUP ANALYSIS OF VARIOUS THINGS FOUND ABOVE
library(clusterProfiler)
library(enrichplot)
library(biomaRt)
library(AnnotationDbi)
library(annotables)
grcm38 <- grcm38
source("functions/gettop10GO.R")
source("functions/gettop10GO_low_sensitivity.R")
#1st - pull TREATMENT_limma_results1 <- readRDS("results/TREATMENT_limma_results.RDS")
#2nd - filter genes that are only in modules of interest - call them MEcolor
#3rd - attach LH_limma_results1 to filteres MEcolor datasets
#4th - do GO analysis of merged MEcolor-limma datasets
#5th - and highest MM ranking of MEcolor datasets
## steps 1-3
TREATMENT_limma_results1 <- readRDS("results/TREATMENT_limma_results.RDS")
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
gene.signf.corr2 <- as.data.frame(gene.signf.corr)
gene.signf.corr2 <- tibble::rownames_to_column(gene.signf.corr2, "symbol")
colnames(gene.signf.corr2)[2] <- "gene.signif.corr"
gene.signf.corr.pvals2 <- as.data.frame(gene.signf.corr.pvals)
gene.signf.corr.pvals2 <- tibble::rownames_to_column(gene.signf.corr.pvals2, "symbol")
colnames(gene.signf.corr.pvals2)[2] <- "gene.signif.corr.pval"
MEallcolors2 <- left_join(MEallcolors, gene.signf.corr2, by = "symbol") %>%
left_join(., gene.signf.corr.pvals2, by = "symbol")
# write.csv(MEallcolors2, "results/results_tables/MEallcolors_TREATMENT.csv")
module.membership.measure2 <- as.data.frame(module.membership.measure)
module.membership.measure2 <- tibble::rownames_to_column(module.membership.measure2, "module")
# # salmon
# MEsalmon <- MEallcolors2 %>%
#   filter(MEcolor == "salmon")
#
# write.csv(MEsalmon, "results/MEsalmon.csv")
# MEsalmon.limma <- TREATMENT_limma_results1 %>%
#   left_join(MEsalmon, by = "symbol") %>%
#   filter(!is.na(MEcolor)) %>%
#   select(1,2,3,4,9,11,12)
#
# salmonlm <- lm(MEsalmon ~ treatment_bin, heatmap.data)
# summary(salmonlm)
#
# t.test(MEsalmon ~ treatment_bin, heatmap.data)
#
# source("functions/geom_boxjitter.R")
# heatmap.data3 <- heatmap.data
# heatmap.data3$treatment_bin <- as.factor(heatmap.data3$treatment_bin)
# heatmap.data3$treatment <- ifelse(heatmap.data3$treatment_bin == 0, "Oil", "OPFR")
# ggplot(aes(treatment, MEsalmon, fill = treatment), data = heatmap.data3)+
#   geom_boxjitter(outlier.color = NA, jitter.shape = 21,
#                  alpha = 1,
#                  width = 0.5,
#                  jitter.height = 0.02, jitter.width = 0.02, errorbar.draw = TRUE,
#                  position = position_dodge(0.8)) +
#   scale_fill_manual(values=c("skyblue", "pink")) +
#   labs(title="Salmon Module",x="Treatment", y = "MEsalmon Value") +
#   theme_classic() +
#   theme(axis.line = element_line(colour = 'black', size = 1),
#         axis.ticks = element_line(colour = "black", size = 1),
#         legend.position="none",
#         axis.text=element_text(size=16),
#         axis.title=element_text(size=18,face="bold"),
#         plot.title = element_text(size=24, hjust = 0.4)) +
#   annotate("text", x = 1.4, y = .6, label = "p = 0.03", size = 8)
####
traits <- colData %>%
mutate(treatment_bin = ifelse(grepl('OPFR', treatment), 1, 0)) %>%
select(6)
colData$E_level_bin <- factor(colData$E_level, levels = c("M", "low", "high"))
E_level.out <- binarizeCategoricalColumns(colData$E_level_bin,
includePairwise = TRUE,
includeLevelVsAll = FALSE,
minCount = 1)
traits <- cbind(traits, E_level.out)
# in r, i have a df called "colData". from this, I want to make a new df called "traits". in traits, I want to make binarized category columns for each combination of values in column colData$treatment and colData$E_level.
traits <- colData %>%
mutate(combination = paste(treatment, E_level, sep = "_")) %>%
pivot_wider(names_from = combination, values_from = combination,
values_fn = length, values_fill = 0) %>%
mutate(across(everything(), ~ as.numeric(. > 0))) %>%
select("Oil_M","OPFR_M","Oil_low","OPFR_low","Oil_high","OPFR_high")
traits <- traits %>%
mutate(rowname = rownames(colData)) %>%
column_to_rownames("rowname")
treattrait <- colData %>%
mutate('OPFR_treatment' = ifelse(grepl('OPFR', treatment), 1, 0)) %>%
select(7)
traits <- cbind(treattrait, traits)
# Define numbers of genes and samples
nSamples <- nrow(norm.counts)
nGenes <- ncol(norm.counts)
module.trait.corr <- cor(module_eigengenes, traits, use = 'p')
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)
# visualize module-trait association as a heatmap
heatmap.data <- merge(module_eigengenes, traits, by = 'row.names')
head(heatmap.data)
heatmap.data <- heatmap.data %>%
column_to_rownames(var = 'Row.names')
heatmap.data2 <- heatmap.data
module.gene.mapping <- as.data.frame(bwnet$colors)
MEallcolors <- tibble::rownames_to_column(module.gene.mapping, "symbol")
colnames(MEallcolors)[2] <- "MEcolor"
color_counts <- table(MEallcolors$MEcolor)
column_names <- colnames(heatmap.data2)
new_column_names <- sapply(column_names, function(col) {
# Extract the color part (e.g., "MEblack" -> "black")
color <- sub("ME", "", col)
# If the color exists in the color_counts, add the count to the column name
if (color %in% names(color_counts)) {
paste0(col, "(", color_counts[color], ")")
} else {
col # Leave the column name unchanged if the color is not found
}
})
colnames(heatmap.data2) <- new_column_names
names(heatmap.data2)
#1400x850
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[15:20],
y = names(heatmap.data2)[1:14],
col = c("skyblue", "lightblue", "white", "pink", "hotpink"),
main = "WGCNA Module Eigengene Comparisons",
fontCorval = 2,
cexCorval = 1.6,
cexLabY = 1.5,
cexLabX = 1.5)
module.gene.mapping <- as.data.frame(bwnet$colors)
#1400x850
CorLevelPlot(heatmap.data2,
x = names(heatmap.data2)[15:21],
y = names(heatmap.data2)[1:14],
col = c("skyblue", "lightblue", "white", "pink", "hotpink"),
main = "WGCNA Module Eigengene Comparisons",
fontCorval = 2,
cexCorval = 1.6,
cexLabY = 1.5,
cexLabX = 1.5)
View(heatmap.data2)
View(heatmap.data2)
